// swift-interface-format-version: 1.0
// swift-compiler-version: Apple Swift version 5.7.2 (swiftlang-5.7.2.135.5 clang-1400.0.29.51)
// swift-module-flags: -target x86_64-apple-ios12.0-simulator -enable-objc-interop -enable-library-evolution -swift-version 5 -enforce-exclusivity=checked -O -module-name SecureAccess
// swift-module-flags-ignorable: -enable-bare-slash-regex
import CommonCrypto
import CoreBluetooth
import CoreLocation
import CryptoKit
import Foundation
@_exported import SecureAccess
import Security
import Swift
import _Concurrency
import _StringProcessing
public enum TapToAccessError : Swift.Error {
  case invalidTransition
  case orgInvalidPayload
  case missingLogin
  case readerProofInvalidPayload
  case certificateInvalidPayload
  case failedToEncrypt
  case failedToDecrypt
  case scramFetchError
  case scramFetchDenied
  case scramFetchNoNetwork
  case failedToVerifyReaderProof
  case needsDeviceOwnerVerification
  case unexpectedCommand
  case missingDelegate
  case offsetReadOutOfBounds
  case unrecognizedEvent
  public static func == (a: SecureAccess.TapToAccessError, b: SecureAccess.TapToAccessError) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
extension Foundation.NSNotification.Name {
  public static var ReaderManagerDidEnterNotification: Foundation.Notification.Name {
    get
  }
  public static var ReaderManagerDidExitNotification: Foundation.Notification.Name {
    get
  }
}
@objc extension Foundation.NSNotification {
  @objc public static let ReaderManagerDidEnterNotification: Foundation.Notification.Name
  @objc public static let ReaderManagerDidExitNotification: Foundation.Notification.Name
}
public struct SecureAccessLogger {
  public static var info: ((_ message: Swift.String, _ file: Swift.String, _ function: Swift.String) -> Swift.Void)?
  public static var error: ((_ message: Swift.String, _ file: Swift.String, _ function: Swift.String) -> Swift.Void)?
}
public struct Login {
  public var id: Swift.Int
  public var token: Swift.String
  public var key: Swift.String
  public var certificate: Swift.String
  public init(id: Swift.Int, token: Swift.String, key: Swift.String, certificate: Swift.String)
}
extension SecureAccess.Login : Swift.CustomStringConvertible {
  public var description: Swift.String {
    get
  }
}
public struct BeaconLock : Swift.Identifiable, Swift.Equatable, Swift.Codable {
  public var id: Swift.Int
  public var oneTimePassword: Swift.Int
  public static func == (a: SecureAccess.BeaconLock, b: SecureAccess.BeaconLock) -> Swift.Bool
  public typealias ID = Swift.Int
  public func encode(to encoder: Swift.Encoder) throws
  public init(from decoder: Swift.Decoder) throws
}
@objc @_hasMissingDesignatedInitializers @available(iOS 13.0, *)
final public class ReaderManager : ObjectiveC.NSObject {
  public static let shared: SecureAccess.ReaderManager
  final public var enteredBeaconsLocks: [CoreLocation.CLBeaconRegion : [SecureAccess.BeaconLock]] {
    get
  }
  @objc deinit
}
@available(iOS 13.0, *)
extension SecureAccess.ReaderManager {
  final public func startMonitoring()
  final public func stopMonitoring()
  final public func startRanging()
  final public func stopRanging()
  final public func isNearbyLock(_ id: Swift.Int) -> Swift.Bool
  final public func proximityProofForLock(_ id: Swift.Int) -> Swift.Int?
}
@available(iOS 13.0, *)
extension SecureAccess.ReaderManager : CoreLocation.CLLocationManagerDelegate {
  @objc final public func locationManager(_ manager: CoreLocation.CLLocationManager, didChangeAuthorization status: CoreLocation.CLAuthorizationStatus)
  @objc final public func locationManager(_ manager: CoreLocation.CLLocationManager, didFailWithError error: Swift.Error)
  @objc final public func locationManager(_ manager: CoreLocation.CLLocationManager, didStartMonitoringFor region: CoreLocation.CLRegion)
  @objc final public func locationManager(_ manager: CoreLocation.CLLocationManager, monitoringDidFailFor region: CoreLocation.CLRegion?, withError error: Swift.Error)
  @objc final public func locationManager(_ manager: CoreLocation.CLLocationManager, didEnterRegion region: CoreLocation.CLRegion)
  @objc final public func locationManager(_ manager: CoreLocation.CLLocationManager, didExitRegion region: CoreLocation.CLRegion)
  @objc final public func locationManager(_ manager: CoreLocation.CLLocationManager, didRangeBeacons beacons: [CoreLocation.CLBeacon], in region: CoreLocation.CLBeaconRegion)
  @objc final public func locationManager(_ manager: CoreLocation.CLLocationManager, rangingBeaconsDidFailFor region: CoreLocation.CLBeaconRegion, withError error: Swift.Error)
}
@objc @_hasMissingDesignatedInitializers @available(iOS 13.0, *)
final public class TapToAccessManager : ObjectiveC.NSObject {
  @objc public static let shared: SecureAccess.TapToAccessManager
  weak final public var delegate: SecureAccess.TapToAccessDelegate? {
    get
    set
  }
  @objc final public func start()
  @objc final public func stop()
  @objc deinit
}
@available(iOS 13.0, *)
extension SecureAccess.TapToAccessManager : CoreBluetooth.CBPeripheralManagerDelegate {
  @objc final public func peripheralManagerDidUpdateState(_ peripheral: CoreBluetooth.CBPeripheralManager)
  @objc final public func peripheralManager(_ peripheral: CoreBluetooth.CBPeripheralManager, didReceiveRead request: CoreBluetooth.CBATTRequest)
  @objc final public func peripheralManager(_ peripheral: CoreBluetooth.CBPeripheralManager, didReceiveWrite requests: [CoreBluetooth.CBATTRequest])
  @objc final public func peripheralManager(_ peripheral: CoreBluetooth.CBPeripheralManager, didAdd service: CoreBluetooth.CBService, error: Swift.Error?)
  @objc final public func peripheralManagerDidStartAdvertising(_ peripheral: CoreBluetooth.CBPeripheralManager, error: Swift.Error?)
  @objc final public func peripheralManager(_ peripheral: CoreBluetooth.CBPeripheralManager, willRestoreState dict: [Swift.String : Any])
}
public protocol TapToAccessDelegate : AnyObject {
  func tapToAccessSuccess(online: Swift.Bool, duration: Foundation.TimeInterval)
  func tapToAccessFailure(error: SecureAccess.TapToAccessError, duration: Foundation.TimeInterval)
  func tapToAccessClientID() -> Swift.Int
  func tapToAccessLoginForOrganization(_ organization: Swift.Int?) -> SecureAccess.Login?
}
extension SecureAccess.TapToAccessError : Swift.Equatable {}
extension SecureAccess.TapToAccessError : Swift.Hashable {}
